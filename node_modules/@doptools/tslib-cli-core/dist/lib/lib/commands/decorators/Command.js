"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IntegerFlag = exports.HelpFlag = exports.StringFlag = exports.BooleanFlag = exports.Argument = exports.CliCommand = void 0;
const command_1 = require("@oclif/command");
const propertyKeyField = Symbol.for('hiden property to store propKey');
function gatherKeys(target) {
    var _a;
    const data = { arg: new Map(), flag: new Map() };
    const parent = Object.getPrototypeOf(target);
    if (parent && parent.name && parent !== Object) {
        const pdata = gatherKeys(parent);
        // args dont inherit
        pdata.flag.forEach((v, k) => {
            data.flag.set(k, v);
        });
    }
    (_a = target.args) === null || _a === void 0 ? void 0 : _a.forEach(arg => {
        const pk = arg[propertyKeyField];
        data.arg.set(pk, arg);
    });
    if (target.flags) {
        for (const key in target.flags) {
            if (Object.prototype.hasOwnProperty.call(target.flags, key)) {
                const flag = target.flags[key];
                const pk = flag[propertyKeyField];
                data.flag.set(pk, flag);
            }
        }
    }
    return data;
}
function CliCommand(desc) {
    return (target) => {
        const keys = gatherKeys(target);
        const args = Array.from(keys.arg.values());
        const flags = Object.fromEntries(keys.flag.entries());
        const Base = target;
        class Cmd extends Base {
            constructor(...arg) {
                super(...arg);
                const parsed = this.parse(Cmd);
                const args = parsed.args;
                const flags = parsed.flags;
                const self = this;
                keys.arg.forEach((arg, key) => {
                    self[key] = args[arg.name];
                });
                keys.flag.forEach((flag, key) => {
                    self[key] = flags[flag.name];
                });
                self.arguments = args;
                self.flags = flags;
            }
        }
        Cmd.args = args;
        Cmd.flags = flags;
        Cmd.aliases = desc.aliases;
        Cmd.description = desc.description;
        Cmd.examples = desc.examples;
        Cmd.id = desc.id;
        Cmd.usage = desc.usage;
        return Cmd;
    };
}
exports.CliCommand = CliCommand;
function Argument(...args) {
    let desc = {};
    if (args.length === 1) {
        if (typeof args[0] === 'boolean') {
            desc.required = args[0];
        }
        else if (typeof args[0] === 'string') {
            desc.name = args[0];
        }
        else if (typeof args[0] === 'object') {
            desc = args[0];
        }
    }
    else if (args.length === 2) {
        desc.name = args[0];
        desc.required = args[1];
    }
    return (target, key) => {
        var _a, _b;
        const cfg = { ...desc, [propertyKeyField]: key };
        (_a = cfg.name) !== null && _a !== void 0 ? _a : (cfg.name = key.toString());
        const Cmd = target.constructor;
        (_b = Cmd.args) !== null && _b !== void 0 ? _b : (Cmd.args = []);
        Cmd.args.push(cfg);
    };
}
exports.Argument = Argument;
function createFlagDecorator(desc) {
    return (target, key) => {
        var _a, _b, _c;
        const cfg = { ...desc };
        (_a = cfg.name) !== null && _a !== void 0 ? _a : (cfg.name = key.toString());
        (_b = cfg.char) !== null && _b !== void 0 ? _b : (cfg.char = cfg.name.charAt(0));
        const Cmd = target.constructor;
        (_c = Cmd.flags) !== null && _c !== void 0 ? _c : (Cmd.flags = {});
        let config;
        switch (cfg.type) {
            case 'boolean':
                config = command_1.flags.boolean(cfg);
                break;
            case 'integer':
                config = command_1.flags.integer(cfg);
                break;
            case 'help':
                config = command_1.flags.help(cfg);
                break;
            case 'string':
            default:
                config = command_1.flags.string(cfg);
                break;
        }
        Cmd.flags[cfg.name] = { ...config, [propertyKeyField]: key };
    };
}
function createFlagAnnotation(type, config) {
    return createFlagDecorator(Object.assign({}, config, { type }));
}
function BooleanFlag(desc) {
    return createFlagAnnotation('boolean', desc !== null && desc !== void 0 ? desc : {});
}
exports.BooleanFlag = BooleanFlag;
function StringFlag(desc) {
    return createFlagAnnotation('string', desc !== null && desc !== void 0 ? desc : {});
}
exports.StringFlag = StringFlag;
function HelpFlag(desc) {
    return createFlagAnnotation('help', desc !== null && desc !== void 0 ? desc : {});
}
exports.HelpFlag = HelpFlag;
function IntegerFlag(desc) {
    return createFlagAnnotation('integer', desc !== null && desc !== void 0 ? desc : {});
}
exports.IntegerFlag = IntegerFlag;
//# sourceMappingURL=Command.js.map