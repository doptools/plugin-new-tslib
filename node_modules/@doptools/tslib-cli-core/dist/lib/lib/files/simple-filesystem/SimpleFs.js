"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SimpleFs = void 0;
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
const jsonc_1 = require("jsonc");
const path_1 = require("path");
const yaml = __importStar(require("yaml"));
class SimpleFs {
    constructor(enforceRootDir = false) {
        this.enforceRootDir = enforceRootDir;
        this._cwd = '.';
    }
    get root() {
        return path_1.posix.normalize(process.cwd() + '/');
    }
    get cwd() {
        return path_1.posix.relative(path_1.posix.normalize(process.cwd()), this._cwd) || '/';
    }
    async read(path) {
        path = this.resolve(path);
        try {
            return await promises_1.readFile(path);
        }
        catch {
            return null;
        }
    }
    async readText(path) {
        const data = await this.read(path);
        return data ? data.toString('utf-8') : null;
    }
    async readJson(path) {
        const data = await this.readText(path);
        return data ? jsonc_1.jsonc.parse(data, { stripComments: true }) : null;
    }
    async readYaml(path) {
        const data = await this.readText(path);
        return data ? yaml.parse(data, { prettyErrors: true }) : null;
    }
    async create(path, data) {
        await this.ensureNotExists(path);
        await promises_1.mkdir(path_1.posix.dirname(path), { recursive: true });
        await promises_1.writeFile(path, data, typeof data === 'string' ? 'utf-8' : 'binary');
    }
    async createText(path, data) {
        await this.create(path, data);
    }
    async createJson(path, data) {
        await this.createText(path, this.toJsonString(data));
    }
    toJsonString(data) {
        return jsonc_1.jsonc.stringify(data, { space: 2, handleCircular: false });
    }
    async createYaml(path, data) {
        await this.createText(path, this.toYamlString(data));
    }
    toYamlString(data) {
        return yaml.stringify(data, { indent: 2, prettyErrors: true });
    }
    async overwrite(path, data) {
        await this.ensureExists(path);
        await promises_1.writeFile(path, data, typeof data === 'string' ? 'utf-8' : 'binary');
    }
    async overwriteText(path, data) {
        await this.overwrite(path, data);
    }
    async overwriteJson(path, data) {
        await this.overwriteText(path, this.toJsonString(data));
    }
    async overwriteYaml(path, data) {
        await this.overwriteText(path, this.toYamlString(data));
    }
    async delete(path) {
        await this.ensureExists(path);
        await promises_1.unlink(this.resolve(path));
    }
    async rename(from, to) {
        await this.ensureExists(from);
        await this.ensureNotExists(to);
        await promises_1.rename(this.resolve(from), this.resolve(to));
    }
    exists(path) {
        return Promise.resolve(this.existsSync(path));
    }
    existsSync(path) {
        return fs_1.existsSync(this.resolve(path));
    }
    async list(path) {
        await this.ensureExists(path);
        return (await promises_1.readdir(this.resolve(path))).filter(_ => _ !== '.' && _ !== '..');
    }
    cd(path) {
        this.ensureExistsSync(path);
        path = this.resolve(path);
        this._cwd = path;
    }
    buildPath(path) {
        if (path_1.posix.isAbsolute(path)) {
            const trueRoot = path_1.posix.normalize(process.cwd() + '/');
            let target = path_1.posix.join(trueRoot, `./${path}`);
            target = path_1.posix.relative(trueRoot, target);
            return target;
        }
        path = path_1.posix.normalize(path_1.posix.join(this._cwd, path));
        return path;
    }
    resolve(path) {
        let target = this.buildPath(path);
        if (target.startsWith('..')) {
            if (this.enforceRootDir || this.root === '/') {
                throw new Error(`Path '${path}' is invalid. Resolves below root : '/${target}'`);
            }
        }
        target = path_1.posix.normalize(path_1.posix.join(this.root, target));
        target = path_1.posix.relative(this.root, target);
        return target || this.root;
    }
    async ensureExists(path) {
        return Promise.resolve(this.ensureExistsSync(path));
    }
    ensureExistsSync(path) {
        if (!this.existsSync(path)) {
            throw new Error(`${path} does not exist.`);
        }
    }
    async ensureNotExists(path) {
        return Promise.resolve(this.ensureNotExistsSync(path));
    }
    ensureNotExistsSync(path) {
        if (this.existsSync(path)) {
            throw new Error(`${path} already exist.`);
        }
    }
}
exports.SimpleFs = SimpleFs;
//# sourceMappingURL=SimpleFs.js.map