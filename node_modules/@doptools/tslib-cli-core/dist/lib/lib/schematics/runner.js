"use strict";
/**
 * derived from https://github.com/angular/angular-cli/blob/master/packages/angular_devkit/schematics_cli/bin/schematics.ts
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchematicRunner = exports.ContextIsReadonlyError = exports.RuleRunner = void 0;
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const tools_1 = require("@angular-devkit/schematics/tools");
const chalk_1 = __importDefault(require("chalk"));
const node_1 = require("@angular-devkit/core/node");
const inquirer = __importStar(require("inquirer"));
const schematics_1 = require("@angular-devkit/schematics");
const path_1 = __importDefault(require("path"));
const colors = new chalk_1.default.Instance({ level: 3 });
class RuleRunner {
    constructor(_runner, _options = {}) {
        this._runner = _runner;
        this._options = _options;
    }
    static create(options) {
        const runner = SchematicRunner.create(path_1.default.resolve(__dirname, '../../../../run-rules'), options);
        return new RuleRunner(runner, options);
    }
    execute(rules) {
        return this._runner.execute({ rules });
        ;
    }
}
exports.RuleRunner = RuleRunner;
class ContextIsReadonlyError extends Error {
}
exports.ContextIsReadonlyError = ContextIsReadonlyError;
class SchematicRunner {
    constructor(_path, options = {}) {
        var _a, _b, _c, _d, _e, _f;
        this._path = _path;
        options = { ...options };
        (_a = options.dryRun) !== null && _a !== void 0 ? _a : (options.dryRun = false);
        (_b = options.force) !== null && _b !== void 0 ? _b : (options.force = options.dryRun);
        (_c = options.verbose) !== null && _c !== void 0 ? _c : (options.verbose = false);
        (_d = options.interactive) !== null && _d !== void 0 ? _d : (options.interactive = true);
        (_e = options.cwd) !== null && _e !== void 0 ? _e : (options.cwd = process.cwd());
        (_f = options.mode) !== null && _f !== void 0 ? _f : (options.mode = 'rw');
        this._options = options;
        this._collectionName = path_1.default.dirname(_path);
        this._schematicName = path_1.default.basename(_path);
        this._logger = node_1.createConsoleLogger(options === null || options === void 0 ? void 0 : options.verbose, process.stdout, process.stderr, {
            info: s => s,
            debug: s => s,
            warn: s => colors.bold.yellow(s),
            error: s => colors.bold.red(s),
            fatal: s => colors.bold.red(s),
        });
    }
    static create(path, options) {
        return new SchematicRunner(path, options);
    }
    execute(options) {
        return this.createWorkflowRun()(options);
    }
    createWorkflowRun() {
        let nothingDone = true;
        let error = false;
        let loggingQueue = [];
        const { cwd, force, dryRun, interactive, allowPrivate } = this._options;
        const workflow = new tools_1.NodeWorkflow(cwd, {
            force,
            dryRun,
            resolvePaths: [cwd, __dirname],
            schemaValidation: true
        });
        workflow.reporter.subscribe((event) => {
            nothingDone = false;
            if (this._options.mode === 'ro') {
                throw new Error('Context is readonly');
            }
            // Strip leading slash to prevent confusion.
            const eventPath = event.path.startsWith('/') ? event.path.substr(1) : event.path;
            switch (event.kind) {
                case 'error':
                    error = true;
                    const desc = event.description === 'alreadyExist' ? 'already exists' : 'does not exist';
                    this._logger.error(`ERROR! ${eventPath} ${desc}.`);
                    break;
                case 'update':
                    loggingQueue.push(`${colors.cyan('UPDATE')} ${eventPath} (${event.content.length} bytes)`);
                    break;
                case 'create':
                    loggingQueue.push(`${colors.green('CREATE')} ${eventPath} (${event.content.length} bytes)`);
                    break;
                case 'delete':
                    loggingQueue.push(`${colors.yellow('DELETE')} ${eventPath}`);
                    break;
                case 'rename':
                    const eventToPath = event.to.startsWith('/') ? event.to.substr(1) : event.to;
                    loggingQueue.push(`${colors.blue('RENAME')} ${eventPath} => ${eventToPath}`);
                    break;
            }
        });
        /**
         * Listen to lifecycle events of the workflow to flush the logs between each phases.
         */
        workflow.lifeCycle.subscribe(event => {
            if (event.kind === 'workflow-end' || event.kind === 'post-tasks-start') {
                if (!error) {
                    // Flush the log queue and clean the error state.
                    loggingQueue.forEach(log => this._logger.info(log));
                }
                loggingQueue = [];
                error = false;
            }
        });
        // Show usage of deprecated options
        workflow.registry.useXDeprecatedProvider(msg => this._logger.warn(msg));
        // Add prompts.
        if (interactive !== false && isTTY()) {
            workflow.registry.usePromptProvider(_createPromptProvider());
        }
        return async (options) => {
            /**
             *  Execute the workflow, which will report the dry run events, run the tasks, and complete
             *  after all is done.
             *
             *  The Observable returned will properly cancel the workflow if unsubscribed, error out if ANY
             *  step of the workflow failed (sink or task), with details included, and will only complete
             *  when everything is done.
             */
            options = {
                ...this._options,
                ...options
            };
            try {
                await workflow.execute({
                    collection: this._collectionName,
                    schematic: this._schematicName,
                    options,
                    allowPrivate: allowPrivate,
                    debug: false,
                    logger: this._logger,
                }).toPromise();
                if (nothingDone && this._options.mode === 'rw') {
                    this._logger.info(colors.gray('Nothing to be done.'));
                }
                if (!nothingDone && this._options.mode === 'rw' && this._options.dryRun) {
                    this._logger.info(colors.yellow('Dry run: no changes where made.'));
                }
                return !nothingDone;
            }
            catch (err) {
                if (err instanceof schematics_1.UnsuccessfulWorkflowExecution) {
                    // "See above" because we already printed the error.
                    this._logger.fatal('The Schematic workflow failed. See above.');
                }
                else {
                    this._logger.fatal(err.stack || err.message);
                }
                throw err;
            }
        };
    }
}
exports.SchematicRunner = SchematicRunner;
function isTTY() {
    const isTruthy = (value) => {
        // Returns true if value is a string that is anything but 0 or false.
        return value !== undefined && value !== '0' && value.toUpperCase() !== 'FALSE';
    };
    // If we force TTY, we always return true.
    const force = process.env['NG_FORCE_TTY'];
    if (force !== undefined) {
        return isTruthy(force);
    }
    return !!process.stdout.isTTY && !isTruthy(process.env['CI']);
}
function _createPromptProvider() {
    return (definitions) => {
        const questions = definitions.map(definition => {
            const question = {
                name: definition.id,
                message: definition.message,
                default: definition.default,
            };
            const validator = definition.validator;
            if (validator) {
                question.validate = input => validator(input);
            }
            switch (definition.type) {
                case 'confirmation':
                    return { ...question, type: 'confirm' };
                case 'list':
                    return {
                        ...question,
                        type: definition.multiselect ? 'checkbox' : 'list',
                        choices: definition.items && definition.items.map(item => {
                            if (typeof item === 'string') {
                                return item;
                            }
                            else {
                                return {
                                    name: item.label,
                                    value: item.value,
                                };
                            }
                        }),
                    };
                default:
                    return { ...question, type: definition.type };
            }
        });
        return inquirer.prompt(questions);
    };
}
//# sourceMappingURL=runner.js.map